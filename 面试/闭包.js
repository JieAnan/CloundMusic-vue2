
/* 
1.函数声明： 使用function关键字声明一个函数，再指定一个含糊么，就叫做函数声明。
eg: function fnName () { 方法体 };

2.函数表达式：使用function关键字声明一个函数，但未给函数命名(匿名函数)
             最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。
eg: let fn1 = function () { 方法体 };

3.匿名函数：使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，
           匿名函数属于函数表达式，匿名函数有很多作用，
           赋予一个变量则创建函数，
           赋予一个事件则成为事件处理程序或创建闭包等等。


4.函数声明和函数表达式区别： 
         1.Javascript引擎在解析javascript代码时会‘函数声明提升’当前执行环境（作用域）上的函数声明，
           而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式；
           也就是说：【函数声明会在编译时时候进行解析，而匿名函数只有再执行到改行时候才会解析该函数】

        2.函数表达式后面可以加括号【立即调用该函数】，
          函数声明不可以，只能以fnName()形式调用 。
          【注意】：加括号只对匿名函数起作用，表示解析到时候马上执行该函数，函数声明后面加括号不起作用会自动忽略。
          【注意】: 如果匿名函数不进行赋值操作，那么js会默认function 为函数声明关键字，如果在后面加货号会报错。

5.立即执行函数：立即执行函数是针对js中的函数表达式而言，因此对于函数表达式，
              第一行不能以function开通否则js解析为函数声明，那么如何书写立即执行函数呢？
              方式一：
              (function(){}())
              方式二：
              (function(){})()
              这两种方式再开头使用括号避免了js解析为函数声明，从而在结尾添加()进行立即执行
              （表示js解析到马上执行）

6.立即执行函数优点：
              1.不必为函数命名，避免了污染全局变量。
              2.立即执行函数内部形成了一个独立的作用域，可以封装一些外部无法读取的私有变量，
                这个作用域里面的变量，外面访问不到，这样就可以避免变量污染。

  总结：立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。

 */

/* 
闭包：一个拥有许多变量和绑定这些变量执行上下文环境的表达式，通常一函数形式存在。

闭包两个特点： 1.函数内部对外部变量进行引用。  2.函数的上下文环境需要函数执行完毕才会被释放。

作用：【将某些变量维持在特定空间之中】。 
*/


/* 1.手写一个函数：第一次调用输出1，第二次调用输出2,依次迭代... */

const FirstAdd = function () {
  let count = 0;
  return function () {
    count += 1;
    return count;
  };
}();

console.log('1-数值调用递增函数ing');
console.log(FirstAdd());
console.log(FirstAdd());
console.log(FirstAdd());
console.log(FirstAdd);

/* 说明：
      1.立即执行函数如果没有返回值,那么左边的赋值变量为undefined
        如果有返回值，那么这个左边的赋值变量的值就是 匿名函数的 [返回值]。
        如上述所示:FirstAdd最终是一个匿名函数,而FirstAdd + () 代表立即执行函数. 

*/


/* 2.书写一个 true flase true false 交互调用的函数 */
let exchangeBool = (function () {
  let bool = false;
  return function () {
    bool = !bool;
    return bool;
  }
})();

console.log('2-布尔调用函数ing');
console.log(exchangeBool());
console.log(exchangeBool());
console.log(exchangeBool());
console.log(exchangeBool());



/* 3.使用闭包实现一个函数计算值的 缓存函数  */

/* 4.使用闭包实现一个 栈 stack，包含 push pop len三种方法 */